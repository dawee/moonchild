#!/usr/bin/env node

const argv = require('minimist')(process.argv.slice(2));
const os = require('os');
const fs = require('fs');
const hat = require('hat');
const path = require('path');
const {exec} = require('child_process');
const _mkdirp = require('mkdirp');

const filename = argv._[0];


const mkdirp = dir => new Promise(resolve => _mkdirp(dir, () => resolve()));

const getBinDir = () => new Promise(
  resolve => exec(`npm --prefix ${path.join(__dirname, '..')} bin`, (err, out) => resolve(out.replace(/\s+/g, '')))
);

const writeSketch = (filename, buf) => new Promise(
  resolve => fs.writeFile(filename, template(buf), () => resolve())
);

const luac = (infile, outfile) => getBinDir().then(binDir => new Promise(
  resolve => exec(`${binDir}/luac -o ${outfile} ${infile}`, (err) => resolve())
));

const readLuacBuffer = filename => new Promise(
  resolve => fs.readFile(filename, (err, buf) => resolve(buf))
);


const template = buf => `
/*
 * 
 * 
 *                             :           :                    
 *                            t#,         t#,     L.            
 *                           ;##W.       ;##W.    EW:        ,ft
 *             ..       :   :#L:WE      :#L:WE    E##;       t#E
 *            ,W,     .Et  .KG  ,#D    .KG  ,#D   E###t      t#E
 *           t##,    ,W#t  EE    ;#f   EE    ;#f  E#fE#f     t#E
 *          L###,   j###t f#.     t#i f#.     t#i E#t D#G    t#E
 *        .E#j##,  G#fE#t :#G     GK  :#G     GK  E#t  f#E.  t#E
 *       ;WW; ##,:K#i E#t  ;#L   LW.   ;#L   LW.  E#t   t#K: t#E
 *      j#E.  ##f#W,  E#t   t#f f#:     t#f f#:   E#t    ;#W,t#E
 *    .D#L    ###K:   E#t    f#D#;       f#D#;    E#t     :K#D#E
 *   :K#t     ##D.    E#t     G#t         G#t     E#t      .E##E
 *   ...      #G      ..       t           t      ..         G#E
 *                                                              
 *                                                              
 *                                                                    ED.         
 *                                  .,                                E#Wi        
 *                                 ,Wt .    .      t              i   E###G.      
 *                                i#D. Di   Dt     Ej            LE   E#fD#W;     
 *                               f#f   E#i  E#i    E#,          L#E   E#t t##L    
 *                             .D#i    E#t  E#t    E#t         G#W.   E#t  .E#K,  
 *                            :KW,     E#t  E#t    E#t        D#K.    E#t    j##f 
 *                            t#f      E########f. E#t       E#K.     E#t    :E#K:
 *    Lua 5.3.3                ;#G     E#j..K#j... E#t     .E#E.      E#t   t##L  
 *                              :KE.   E#t  E#t    E#t    .K#E        E#t .D#W;   
 *                               .DW:  E#t  E#t    E#t   .K#D         E#tiW#G.    
 *    for Arduino boards           L#, f#t  f#t    E#t  .W#G          E#K##i      
 *                                  jt  ii   ii    E#t :W##########Wt E##D.       
 *                                                 ,;. :,,,,,,,,,,,,,.E#t         
 *                                                                    L:          
 */ 

#include "Arduboy.h"

Arduboy arduboy;

static unsigned char lua_program[] = {
${[...buf.entries()].map(
  ([index, val]) => `  0x${val.toString(16)}`
).join(',\n')}
};

void setup() {
  arduboy.begin();
  arduboy.setFrameRate(15);
}

void loop() {
  if (!(arduboy.nextFrame())) return;

  arduboy.clear();

  // Stuff

  arduboy.display();
}
`;




function usage() {
  console.log('usage: moonchild <LUA FILE>');
}


if (!filename) {
  usage();  
  process.exit(1);
}


if (!fs.existsSync(filename)) {
  console.error(`"${filename}"" does not exist`);
  process.exit(1);  
}

const basename = path.basename(filename, '.lua');
const buildpath = path.join(path.dirname(filename), 'build', basename);
const sketchname = path.join(buildpath, `${basename}.ino`);
const luacTMP = path.join(os.tmpdir(), hat());



mkdirp(buildpath)
  .then(() => luac(filename, luacTMP))
  .then(() => readLuacBuffer(luacTMP))
  .then(buf => writeSketch(sketchname, buf))

