#!/usr/bin/env node

const argv = require('minimist')(process.argv.slice(2));
const os = require('os');
const fs = require('fs');
const hat = require('hat');
const path = require('path');
const ncp = require('ncp');
const {exec} = require('child_process');
const _mkdirp = require('mkdirp');

const filename = argv._[0];


const mkdirp = dir => new Promise(resolve => _mkdirp(dir, () => resolve()));

const getBinDir = () => new Promise(
  resolve => exec(`npm --prefix ${path.join(__dirname, '..')} bin`, (err, out) => resolve(out.replace(/\s+/g, '')))
);

const writeTemplate = (template, filename, buf) => new Promise(
  (resolve, reject) => fs.writeFile(filename, template(parseLuac(buf)), err => {
    if (!!err) return reject(err);

    resolve();
  })
);

const luac = (infile, outfile) => getBinDir().then(binDir => new Promise(
  (resolve, reject) => exec(`${binDir}/luac -o ${outfile} ${infile}`, (err) => {
    if (!!err) return reject(err);

    resolve();
  })
));

const readLuacBuffer = filename => new Promise(
  (resolve, reject) => fs.readFile(filename, (err, buf) => {
    if (!!err) return reject(err);

    resolve(buf);
  })
);

const copyTree = (src, dst) => new Promise(
  (resolve, reject) => ncp(src, dst, err => {
    if (!!err) return reject(err);

    resolve();
  })
);

const sketchTemplate = () => `
/*
 * 
 * 
 *                             :           :                    
 *                            t#,         t#,     L.            
 *                           ;##W.       ;##W.    EW:        ,ft
 *             ..       :   :#L:WE      :#L:WE    E##;       t#E
 *            ,W,     .Et  .KG  ,#D    .KG  ,#D   E###t      t#E
 *           t##,    ,W#t  EE    ;#f   EE    ;#f  E#fE#f     t#E
 *          L###,   j###t f#.     t#i f#.     t#i E#t D#G    t#E
 *        .E#j##,  G#fE#t :#G     GK  :#G     GK  E#t  f#E.  t#E
 *       ;WW; ##,:K#i E#t  ;#L   LW.   ;#L   LW.  E#t   t#K: t#E
 *      j#E.  ##f#W,  E#t   t#f f#:     t#f f#:   E#t    ;#W,t#E
 *    .D#L    ###K:   E#t    f#D#;       f#D#;    E#t     :K#D#E
 *   :K#t     ##D.    E#t     G#t         G#t     E#t      .E##E
 *   ...      #G      ..       t           t      ..         G#E
 *                                                              
 *                                                              
 *                                                                    ED.         
 *                                  .,                                E#Wi        
 *                                 ,Wt .    .      t              i   E###G.      
 *                                i#D. Di   Dt     Ej            LE   E#fD#W;     
 *                               f#f   E#i  E#i    E#,          L#E   E#t t##L    
 *                             .D#i    E#t  E#t    E#t         G#W.   E#t  .E#K,  
 *                            :KW,     E#t  E#t    E#t        D#K.    E#t    j##f 
 *                            t#f      E########f. E#t       E#K.     E#t    :E#K:
 *    Lua 5.3.3                ;#G     E#j..K#j... E#t     .E#E.      E#t   t##L  
 *                              :KE.   E#t  E#t    E#t    .K#E        E#t .D#W;   
 *                               .DW:  E#t  E#t    E#t   .K#D         E#tiW#G.    
 *    for Arduino boards           L#, f#t  f#t    E#t  .W#G          E#K##i      
 *                                  jt  ii   ii    E#t :W##########Wt E##D.       
 *                                                 ,;. :,,,,,,,,,,,,,.E#t         
 *                                                                    L:          
 */

#include "moonchild.h"

void setup() {
  moon_run_generated();
}

void loop() {}
`;

const programTemplate = proto => `
#include "moonchild.h"

const char ${proto.baseName}_func_name[] PROGMEM = "${proto.funcName}";

const moon_instruction ${proto.baseName}_instructions[] PROGMEM = {
${proto.instructions.map(
  instruction => `  {.opcode = ${instruction.opcodeName}, .a = ${instruction.a}, .b = ${instruction.b}, .c = ${instruction.c}},`
).join('\n')}
};

${proto.constants.map(
  (constant, i) => `const int32_t ${proto.baseName}_constants_value_${i} PROGMEM = ${constant};`
).join('\n')}

const moon_value ${proto.baseName}_constants[] PROGMEM = {
${proto.constants.map(
  (constant, i) => `  {.type = LUA_INT, .data_addr = (PGMEM_ADDRESS) &${proto.baseName}_constants_value_${i}},`
).join('\n')}
};

const moon_prototype ${proto.baseName}_prototype PROGMEM = {
  .func_name_size = ${proto.funcName.length},
  .func_name_addr = (PGMEM_ADDRESS) ${proto.baseName}_func_name,
  .instructions_count = ${proto.instructions.length},
  .instructions_addr = (PGMEM_ADDRESS) ${proto.baseName}_instructions,
  .constants_count = ${proto.constants.length},
  .constants_addr = (PGMEM_ADDRESS) ${proto.baseName}_constants,
};

void moon_run_generated() {
  moon_arch_run((PGMEM_ADDRESS) &${proto.baseName}_prototype);
}
`;

const INT_SIZE = 4;
const LUA_INTEGER_SIZE = 8;

const OPCODES_NAMES = [
  'OPCODE_MOVE',
  'OPCODE_LOADK',
  'OPCODE_LOADKX',
  'OPCODE_LOADBOOL',
  'OPCODE_LOADNIL',
  'OPCODE_GETUPVAL',
  'OPCODE_GETTABUP',
  'OPCODE_GETTABLE',
  'OPCODE_SETTABUP',
  'OPCODE_SETUPVAL',
  'OPCODE_SETTABLE',
  'OPCODE_NEWTABLE',
  'OPCODE_SELF',
  'OPCODE_ADD',
  'OPCODE_SUB',
  'OPCODE_MUL',
  'OPCODE_MOD',
  'OPCODE_POW',
  'OPCODE_DIV',
  'OPCODE_IDIV',
  'OPCODE_BAND',
  'OPCODE_BOR',
  'OPCODE_BXOR',
  'OPCODE_SHL',
  'OPCODE_SHR',
  'OPCODE_UNM',
  'OPCODE_BNOT',
  'OPCODE_NOT',
  'OPCODE_LEN',
  'OPCODE_CONCAT',
  'OPCODE_JMP',
  'OPCODE_EQ',
  'OPCODE_LT',
  'OPCODE_LE',
  'OPCODE_TEST',
  'OPCODE_TESTSET',
  'OPCODE_CALL',
  'OPCODE_TAILCALL',
  'OPCODE_RETURN',
  'OPCODE_FORLOOP',
  'OPCODE_FORPREP',
  'OPCODE_TFORCALL',
  'OPCODE_TFORLOOP',
  'OPCODE_SETLIST',
  'OPCODE_CLOSURE',
  'OPCODE_VARARG',
  'OPCODE_EXTRAAR',
];

const OPCODES = {};

for (const [val, name] of OPCODES_NAMES.entries()) {
  OPCODES[name] = val;
}

class LuacParser {

  constructor(buf) {
    this.buf = buf;
    this.cursor = 0;
    this.proto = {};
  }

  readByte() {
    const byte = this.buf[this.cursor];

    this.cursor++;
    return byte;
  }

  skipBytes(count)Â {
    this.cursor += count;
  }

  readFuncName() {
    this.proto.funcNameSize = this.readByte() - 1;
    this.proto.funcName = '';

    for (let index = 0; index < this.proto.funcNameSize; ++index) {
      this.proto.funcName += String.fromCharCode(this.readByte());
    }

    this.proto.baseName = this.proto.funcName.replace(/\W+/g, "_");
  }

  _readInt(size) {
    let res = 0;

    for (let index = 0; index < size; ++index) {
      res += (this.readByte() << (8 * index));
    }

    return res;    
  }

  readInt() {
    return this._readInt(INT_SIZE);
  }

  readLuaInteger() {
    return this._readInt(LUA_INTEGER_SIZE);
  }

  readInstructions() {
    this.proto.instructionsCount = this.readInt();
    this.proto.instructions = [];

    for (let index = 0; index < this.proto.instructionsCount; ++index) {
      const instruction = {a: 0, b: 0, c: 0};
      const raw = this.readInt();

      instruction.opcode = raw & 0x3F;
      instruction.opcodeName = OPCODES_NAMES[instruction.opcode];
      instruction.a = (raw & 0x3FC0) >> 6;

      if ([OPCODES.OPCODE_LOADK, OPCODES.OPCODE_LOADK].indexOf(instruction.opcode) >= 0) {
        instruction.b = (raw & 0xFFFFC000) >> 14;
      } else {
        instruction.b = (raw & 0xFF800000) >> 23;
        instruction.c = (raw & 0x7FC000) >> 14;
      }

      this.proto.instructions.push(instruction);
    }
  }

  readConstants() {
    this.proto.constantsCount = this.readInt();
    this.proto.constants = [];

    for (let index = 0; index < this.proto.constantsCount; ++index) {
      this.skipBytes(1);  // type
      this.proto.constants.push(this.readLuaInteger());
    }
  }

  parse() {
    this.proto = {};
    this.skipBytes(33);  // header
    this.skipBytes(1);  // sizeup values

    this.readFuncName();

    this.skipBytes(4);  // first line defined
    this.skipBytes(4);  // last line defined
    this.skipBytes(1);  // numparams
    this.skipBytes(1);  // isvarargs
    this.skipBytes(1);  // maxstacksize

    this.readInstructions();
    this.readConstants();

    return this.proto;
  }

}


function parseLuac(buf) {
  if (!buf) return;

  const parser = new LuacParser(buf);

  return parser.parse();
}

function usage() {
  console.log('usage: moonchild <LUA FILE>');
}


if (!filename) {
  usage();  
  process.exit(1);
}


if (!fs.existsSync(filename)) {
  console.error(`"${filename}"" does not exist`);
  process.exit(1);  
}

const basename = path.basename(filename, '.lua');
const buildpath = path.join(path.dirname(filename), 'build', basename);
const sketchname = path.join(buildpath, `${basename}.ino`);
const programname = path.join(buildpath, `program.cpp`);
const luacTMP = path.join(os.tmpdir(), hat());
const libSRC = path.join(__dirname, '..', 'src', 'moonchild');
const libDST = path.join(buildpath); 


mkdirp(buildpath)
  .then(() => luac(filename, luacTMP))
  .catch(err => console.error('Error : Failed to compile Lua script\n', err))
  .then(() => copyTree(libSRC, libDST))
  .catch(err => console.error('Error : Failed copy moonchild lib\n', err))
  .then(() => readLuacBuffer(luacTMP))
  .catch(err => console.error('Error : Failed to read luac output\n', err))
  .then(buf => writeTemplate(programTemplate, programname, buf))
  .catch(err => console.error('Error : Failed to write program\n', err))
  .then(buf => writeTemplate(sketchTemplate, sketchname, buf))
  .catch(err => console.error('Error : Failed to write sketch\n', err))
  .then(() => 'Build done.')

